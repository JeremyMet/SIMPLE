----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 14.07.2017 17:49:21
-- Design Name: 
-- Module Name: ROM - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ROM is
    port(
        clk : in std_logic ;             
        addr : in std_logic_vector(7 downto 0) ;
        data : out std_logic_vector(31 downto 0) := "00000000000000000000000000000000" 
    ) ;         
end ROM;

architecture Behavioral of ROM is

begin

    process(clk)
    begin
        if rising_edge(clk) then
            case addr is
--                when "00000000" => data <= "00101100000000000000000000000011" ; -- ADD R0, R0, $3
--                when "00000001" => data <= "00111000001000000000000000000000" ; -- MUL R1, R0, R0  
--                when "00000010" => data <= "00111000010000010000100000000000" ; -- MUL R2, R1, R1
--                when "00000011" => data <= "00100100000000000000000000000000" ; -- STORE R0, $0
--                when "00000100" => data <= "00100100001000000000100000000000" ; -- STORE R1, $1                
--                when "00000101" => data <= "00100100010000000001000000000000" ; -- STORE R2, $2
--                when "00000110" => data <= "00011100011000000001000000000000" ; -- LOAD R3, $2
--                when "00000111" => data <= "00101100010000110000000000000011" ; -- ADD R2, R3, $3
--                when "00001000" => data <= "00100000010000010000000000000000" ; -- STORE R2, @R1               
--                when "00001001" => data <= "00011100100000000001000000000000" ; -- LOAD R4, $2 
--                when "00001010" => data <= "00100100100000000011100000000000" ; -- STORE R4, $7
--                when "00001011" => data <= "00110100000000000000000000000001" ; -- SUB R0 R0 $1
--                when "00001100" => data <= "00011000111000000000000000000000" ; -- LOAD R7, @R0                                 
--                when "00001101" => data <= "00101100111000110000000000000001" ; -- ADD R7, R7, $1
--                when "00001110" => data <= "00100100111000010000000000000000" ; -- STORE R7, $32                
--                when "00001111" => data <= "01111100000000000000000001000000" ; -- SEQ R0, $2
--                when "00010000" => data <= "01111100000000000000000011000000" ; -- SEQ R0, $3
--                when "00010001" => data <= "01110100000000000000000101000000" ; -- SLT R0, $5
--                when "00010010" => data <= "00101101000010000000000000000001" ; -- ADD R8, R8, $1
--                when "00010011" => data <= "01110101000000000000000010100000" ; -- SLT R8, $5
--                when "00010100" => data <= "10001100010010000000000000000000" ; -- BRFT $18
--                --when "00010100" => data <= "00100100001000000000100000000000" ; -- 
--                when "00010101" => data <= "00100100001000000000100000000000" ; -- STORE R1, $1
--                when "00010110" => data <= "00000100000000000000000000000000" ; -- HALT
--                when others => data <= (others=>'0') ; 
--                -- Naive Exponentiation Algorithm
--                when "00000000" => data <= "00011100010000000000000000000000" ; -- LOAD R2, $0
--                when "00000001" => data <= "00011100001000000000100000000000" ; -- LOAD R1, $1                   
--                --when "00000000" => data <= "00101100010000100000000000000011" ; -- ADD R2, R2, $3
--                --when "00000001" => data <= "00101100001000010000000000000001" ; -- ADD R1, R1, $1
--                when "00000010" => data <= "00010101000000000000000000000000" ; -- MOVE R8, R0 (R8 = 0).                                
--                when "00000011" => data <= "00111000001000010001000000000000" ; -- MUL R1, R1, R2  
--                when "00000100" => data <= "00101101000010000000000000000001" ; -- ADD R8, R8, $1
--                when "00000101" => data <= "01110101000000000000000011100000" ; -- SLT R8, $7
--                when "00000110" => data <= "10001100000011000000000000000000" ; -- BRFT $2
--                when "00000111" => data <= "00100100001000000000000000000000" ; -- STORE R1, $0                
--                when "00001000" => data <= "00000100000000000000000000000000" ; -- HALT
--                when others => data <= (others=>'0') ;
                --when "00000010" => data <= "00111000010000010000100000000000" ; -- MUL R2, R1, R1
                when "00000000" => data <= "00010100001000000000000000000000" ; 
                when "00000001" => data <= "00010100010000000000000000000000" ;
                when "00000010" => data <= "00010100011000000000000000000000" ;
                when "00000011" => data <= "00101100001000010000000000000001" ;
                
                when "00000100" => data <= "00101100010000100000000000000101" ;
                when "00000101" => data <= "00111000001000010001000000000000" ;
                when "00000110" => data <= "00101100011000110000000000000001" ;
                when "00000111" => data <= "01110100011000000000000001100000" ;
                
                when "00001000" => data <= "10001100000101000000000000000000" ;
                when "00001001" => data <= "10000100001010000000000000000000" ;
                when "00001010" => data <= "00100100011000000011100000000000" ;
                when "00001011" => data <= "00000100000000000000000000000000" ;
                
                when others => data <= (others=>'0') ;
                
                 
            end case ;
        end if ;     
    end process ;          
        


end Behavioral;
